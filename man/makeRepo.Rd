% Generated by roxygen2 (4.0.1): do not edit by hand
\name{makeRepo}
<<<<<<< HEAD
\alias{getRversion}
\alias{makeLibrary}
\alias{makeRepo}
\title{Downloads packages from CRAN to specified path and creates repository or library.}
\usage{
makeRepo(pkgs, path, repos = getOption("repos"), type = "source",
  Rversion = getRversion(), download = FALSE, writePACKAGES = TRUE)

getRversion()
=======
\alias{makeLibrary}
\alias{makeRepo}
\alias{twodigitRversion}
\title{Downloads packages from CRAN to specified path and creates repository or library.}
\usage{
makeRepo(pkgs, path, repos = getOption("repos"), type = "source",
  Rversion = twodigitRversion(), download = FALSE, writePACKAGES = TRUE)

twodigitRversion()
>>>>>>> master

makeLibrary(pkgs, path, type = "source")
}
\arguments{
\item{pkgs}{Character vector of packages to download}

\item{type}{Passed to \code{\link{download.packages}}}

\item{Rversion}{String of format "<major R version>.<minor R version>", e.g. "3.2". Only used if \code{type} is not "source"}

<<<<<<< HEAD
  \item{type}{Passed to \code{\link{download.packages}}}

  \item{Rversion}{String of format "<major R
  version>.<minor R version>", e.g. "3.2". Only used if
  \code{type} is not "source"}

  \item{download}{If TRUE downloads packages, otherwise
  just creates PACKAGES file}

  \item{writePACKAGES}{If TRUE, calls
  \code{\link[tools]{write_PACKAGES}} to update the
  repository PACKAGES file}

  \item{path}{Destination download path}

  \item{repos}{URL(s) of the 'contrib' sections of the
  repositories. Passed to \code{\link{available.packages}}}
=======
\item{download}{If TRUE downloads packages, otherwise just creates PACKAGES file}

\item{writePACKAGES}{If TRUE, calls \code{\link[tools]{write_PACKAGES}} to update the repository PACKAGES file}

\item{path}{Destination download path}

\item{repos}{URL(s) of the 'contrib' sections of the repositories. Passed to \code{\link{available.packages}}}
>>>>>>> master
}
\description{
Given a list of packages, downloads to a specified destination folder, then creates PACKAGES file.
}
\details{
<<<<<<< HEAD
The function \code{makeRepo} creates a repository, similar
in structure to CRAN.  It optionally updates the PACKAGES
file.  If done correctly, it is possible to use this folder
as a repository, i.e. it will support functions like
\code{install.packages}.

The function \code{makeLibrary} downloads the packages into
a single folder, i.e. similar to a library on a machine.

Uses \code{\link{download.packages}} and
\code{\link[tools]{write_PACKAGES}}
}
\examples{
# Specify list of packages to download
revolution <- c(CRAN="http://cran.revolutionanalytics.com")
pkgs <- "colorspace"
=======
The function \code{makeRepo} creates a repository, similar in structure to CRAN.  It optionally updates the PACKAGES file.  If done correctly, it is possible to use this folder as a repository, i.e. it will support functions like \code{install.packages}.

The function \code{makeLibrary} downloads the packages into a single folder, i.e. similar to a library on a machine.

Uses \code{\link{download.packages}} and \code{\link[tools]{write_PACKAGES}}
}
\examples{

# Specify list of packages to download
revolution <- c(CRAN="http://cran.revolutionanalytics.com")
pkgs <- "foreach"
>>>>>>> master
pkgList <- pkgDep(pkgs, repos=revolution, type="source")

# Create temporary folder for miniCRAN
dir.create(pth <- file.path(tempdir(), "miniCRAN"))

# Make repo for source and win.binary
makeRepo(pkgList, path=pth, repos=revolution, download=TRUE, writePACKAGES=TRUE, type="source")
makeRepo(pkgList, path=pth, repos=revolution, download=TRUE, writePACKAGES=TRUE, type="win.binary")

# List all files in miniCRAN
list.files(pth, recursive = TRUE)

# Check for available packages
pkgAvail(repos=pth, type="source")
pkgAvail(repos=pth, type="win.binary")

<<<<<<< HEAD
# Delete temporary folder
unlink(pth, recursive = TRUE)
=======
# Plot dependency graph
p <- makeDepGraph(pkgList, repos=revolution)
library(igraph)
plot(p, vertex.size=10, edge.arrow.size=0.5, vertex.label.cex=0.8)

# Delete temporary folder
unlink(pth, recursive = TRUE)

>>>>>>> master
}

